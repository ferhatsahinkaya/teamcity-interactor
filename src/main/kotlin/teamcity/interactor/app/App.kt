/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package teamcity.interactor.app

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.xml.XmlMapper
import com.fasterxml.jackson.module.kotlin.KotlinModule
import com.fasterxml.jackson.module.kotlin.readValue
import feign.Feign
import feign.Logger
import feign.jackson.JacksonDecoder
import feign.jackson.JacksonEncoder
import feign.slf4j.Slf4jLogger
import kotlin.concurrent.fixedRateTimer

data class BuildConfig(val id: String, val names: Set<String>)
data class BuildServerConfig(val baseUrl: String, val waitingBuildsResource: String)
data class TeamCityServerConfig(val baseUrl: String, val buildQueueUrl: String)

class ConfigReader {
    // TODO make this method generic
    fun config(configFile: String): List<BuildConfig> = ObjectMapper()
            .registerModule(KotlinModule())
            .readValue(this::class.java.getResource(configFile))

    fun <T> config(configFile: String, clazz: Class<T>): T = ObjectMapper()
            .registerModule(KotlinModule())
            .readValue(this::class.java.getResource(configFile), clazz)
}

data class BuildMapping(val buildId: String, val responseUrl: String)

fun main(args: Array<String>) {
    val buildConfigs: List<BuildConfig> = ConfigReader().config("build-config.json")
    val buildServerConfig = ConfigReader().config("build-server-config.json", BuildServerConfig::class.java)
    val teamCityServerConfig = ConfigReader().config("teamcity-server-config.json", TeamCityServerConfig::class.java)

    val buildServerClient = Feign.builder()
            .encoder(JacksonEncoder(ObjectMapper().registerModule(KotlinModule())))
            .decoder(JacksonDecoder(ObjectMapper()
                    .registerModule(KotlinModule())
                    .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)))
            .logger(Slf4jLogger(BuildServerClient::class.java))
            .logLevel(Logger.Level.FULL)
            .target(BuildServerClient::class.java, "${buildServerConfig.baseUrl}${buildServerConfig.waitingBuildsResource}");

    val teamCityClient = Feign.builder()
            .encoder(JacksonEncoder(XmlMapper().registerModule(KotlinModule())))
            .decoder(JacksonDecoder(XmlMapper().registerModule(KotlinModule()).disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)))
            .logger(Slf4jLogger(TeamCityClient::class.java))
            .logLevel(Logger.Level.FULL)
            .target(TeamCityClient::class.java, "${teamCityServerConfig.baseUrl}${teamCityServerConfig.buildQueueUrl}");

    val buildStates = mutableMapOf<String, String?>()
    val addedBuilds = mutableListOf<BuildMapping>()

    fixedRateTimer("triggerWaitingBuilds", false, 0L, 5000) {
        buildServerClient.getBuilds()
                .forEach { buildServerBuild ->
                    val build = buildConfigs.first { it.names.any { teamCityBuildName -> teamCityBuildName.toLowerCase() == buildServerBuild.id.toLowerCase() } }
                    val newTeamCityBuild = teamCityClient.build(TeamCityBuild(TeamCityBuildType(build.id)))
                    addedBuilds.add(BuildMapping(newTeamCityBuild.id!!, buildServerBuild.responseUrl))
                    buildStates[newTeamCityBuild.id] = null

                    buildServerClient.deleteBuild(BuildName(buildServerBuild.id))

                    println(buildServerBuild.responseUrl)
                }
    }

    fixedRateTimer("watchBuilds", false, 0L, 5000) {
        addedBuilds
                .forEach {
                    val teamCityBuild = teamCityClient.status(it.buildId)
                    if(teamCityBuild.state != buildStates[it.buildId]) {
                        buildStates[it.buildId] = teamCityBuild.state
                        Feign.builder()
                                .encoder(JacksonEncoder(ObjectMapper().registerModule(KotlinModule())))
                                .logger(Slf4jLogger(ReportingClient::class.java))
                                .logLevel(Logger.Level.FULL)
                                .target(ReportingClient::class.java, it.responseUrl)
                                .report(Report("${teamCityBuild.buildType.id} teamcity build is ${teamCityBuild.state}"));
                    }
                }
    }
}